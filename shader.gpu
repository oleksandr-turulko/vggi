// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex;
attribute vec2 vertexTexture;
uniform mat4 ModelViewProjectionMatrix;
varying vec2 textureCoord;
uniform float b;

uniform vec3 translateSphere;
uniform vec2 userPoint;
uniform float angle;

mat4 translateForPoint(float tx, float ty, float tz) {
    return mat4(
        vec4(1.0, 0.0, 0.0, 0.0),
        vec4(0.0, 1.0, 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(tx, ty, tz, 1.0)
    );
}

mat4 translationForVec(vec3 t) {
    return mat4(
        vec4(1.0, 0.0, 0.0, 0.0),
        vec4(0.0, 1.0, 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(t, 1.0)
    );
}

mat4 rotation(float angleInRadians) {
    float c = cos(angleInRadians);
    float s = sin(angleInRadians);
    return mat4(
        vec4(c, s, 0.0, 0.0),
        vec4(-s, c, 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
    );
}

void main() {
    mat4 rMatrix = rotation(angle);
    mat4 tMatrix1 = translateForPoint(userPoint.x, userPoint.y, 0.0);
    mat4 tMatrix2 = translateForPoint(-userPoint.x, -userPoint.y, 0.0);

    vec4 textureT1 = vec4(vertexTexture, 0.0, 0.0) * tMatrix1;
    vec4 textureR = textureT1 * rMatrix;

    vec4 textureT2 = textureR * tMatrix2;
    textureCoord = vec2(textureT2.x, textureT2.y);

    gl_Position = ModelViewProjectionMatrix * vec4(vertex, 1.0);
    if (b > 0.0) {
        vec4 sphere = translationForVec(translateSphere) * vec4(vertex, 2.0);
        gl_Position = ModelViewProjectionMatrix * sphere;
    }
}`;

// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

varying vec2 textureCoord;
uniform sampler2D tmu;
uniform float b;

void main() {
    vec4 texColor = texture2D(tmu, textureCoord);
    gl_FragColor = (b > 0.0) ? vec4(1.0) : texColor;
}`;
